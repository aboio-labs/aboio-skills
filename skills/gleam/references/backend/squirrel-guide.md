# Squirrel SQL Code Generation Guide

## Overview

Squirrel generates type-safe Gleam functions from SQL files. It reads `.sql` files and produces a `sql.gleam` module with typed functions for each query.

For PostgreSQL type mappings, connection config, and SQL patterns (pagination, upsert, etc.), see the **pg-gleam** skill.

## Critical Rule: One Query Per File

**Squirrel CANNOT handle multiple queries in a single file.**

If you put multiple queries in one file, you will get:

```
Error: cannot insert multiple commands into a prepared statement
```

## Directory Structure

```
module/
├── sql/
│   ├── create_record.sql
│   ├── get_record_by_id.sql
│   ├── list_records.sql
│   ├── update_record.sql
│   └── soft_delete_record.sql
└── sql.gleam  (generated by Squirrel)
```

## SQL File Format

Each SQL file contains exactly ONE query:

### Insert (CREATE)

```sql
-- file: create_user.sql
INSERT INTO users (tenant_id, email, name, created_at)
VALUES ($1, $2, $3, now())
RETURNING id, tenant_id, email, name, created_at;
```

### Select by ID (GET)

```sql
-- file: get_user_by_id.sql
SELECT id, tenant_id, email, name, created_at, updated_at
FROM users
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL;
```

### Select List (LIST)

```sql
-- file: list_users.sql
SELECT id, tenant_id, email, name, is_active, created_at
FROM users
WHERE tenant_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC;
```

### Update

```sql
-- file: update_user.sql
UPDATE users
SET name = $3, email = $4, updated_at = now()
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
RETURNING id, tenant_id, email, name, updated_at;
```

### Soft Delete

```sql
-- file: soft_delete_user.sql
UPDATE users
SET deleted_at = now()
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
RETURNING id;
```

## Running Squirrel

```bash
gleam run -m squirrel
```

This reads all `.sql` files in `module/sql/` directories and generates corresponding `module/sql.gleam` files.

## Generated Code

For a file `create_user.sql`, Squirrel generates:

```gleam
// In module/sql.gleam

pub type CreateUserRow {
  CreateUserRow(
    id: Uuid,
    tenant_id: Uuid,
    email: String,
    name: String,
    created_at: Timestamp,
  )
}

pub fn create_user(
  db: pog.Connection,
  tenant_id: Uuid,
  email: String,
  name: String,
) -> Result(pog.Returned(CreateUserRow), pog.QueryError)
```

## Using Generated Functions

```gleam
import module/sql

pub fn create(db: pog.Connection, tenant_id: Uuid, email: String, name: String)
  -> Result(sql.CreateUserRow, error.Error) {
  case sql.create_user(db, tenant_id, email, name) {
    Ok(returned) ->
      case returned.rows {
        [row] -> Ok(row)
        [] -> Error(error.InternalServerError("Insert returned no rows"))
        _ -> Error(error.InternalServerError("Unexpected result"))
      }
    Error(_) -> Error(error.InternalServerError("Database error"))
  }
}
```

## Handling NULL Columns

For nullable columns, Squirrel generates `Option(T)`:

```sql
-- Column defined as: description TEXT (nullable)
SELECT id, description FROM products WHERE id = $1;
```

Generates:

```gleam
pub type GetProductRow {
  GetProductRow(
    id: Uuid,
    description: Option(String),
  )
}
```

## Handling NULL Parameters

Squirrel infers parameter nullability from the PostgreSQL column definition. Pass `Option` values directly — Squirrel handles `None` as SQL `NULL`:

```gleam
pub fn create(
  db: pog.Connection,
  name: String,
  description: Option(String),
) -> Result(sql.CreateRow, error.Error) {
  case sql.create_record(db, name, description) {
    Ok(returned) -> extract_first(returned.rows)
    Error(_) -> Error(error.InternalServerError("Database error"))
  }
}
```

**Never use sentinel values** like `option.unwrap(description, "")` or `option.unwrap(optional_uuid, uuid.v7())`. These bypass Squirrel's type system and hide nullability.

## Enum Types

Squirrel generates Gleam types for PostgreSQL enums. Prefix enum values to avoid naming conflicts across types:

```sql
-- WRONG - both have "pending"
CREATE TYPE order_status AS ENUM ('pending', 'completed');
CREATE TYPE payment_status AS ENUM ('pending', 'paid');

-- CORRECT - prefixed
CREATE TYPE order_status AS ENUM ('os_pending', 'os_completed');
CREATE TYPE payment_status AS ENUM ('ps_pending', 'ps_paid');
```

Generates:

```gleam
pub type OrderStatus { OsPending, OsCompleted }
pub type PaymentStatus { PsPending, PsPaid }
```

## Naming Conventions

| File Pattern        | Purpose                      | Example                     |
| ------------------- | ---------------------------- | --------------------------- |
| `create_*.sql`      | INSERT                       | `create_user.sql`           |
| `get_*_by_id.sql`   | SELECT single by ID          | `get_user_by_id.sql`        |
| `get_*_by_*.sql`    | SELECT single by other field | `get_user_by_email.sql`     |
| `list_*.sql`        | SELECT multiple              | `list_users.sql`            |
| `update_*.sql`      | UPDATE                       | `update_user.sql`           |
| `soft_delete_*.sql` | Soft delete                  | `soft_delete_user.sql`      |
| `count_*.sql`       | COUNT query                  | `count_users_by_status.sql` |
| `upsert_*.sql`      | INSERT ON CONFLICT           | `upsert_stock.sql`          |

## Troubleshooting

### "cannot insert multiple commands"

You have multiple queries in one file. Split into separate files.

### "unknown type" error

The PostgreSQL type is not supported. Check pg-gleam skill for the supported types list.

### timestamptz not working

Use `timestamp` instead. Gleam handles timezone conversion at application layer.

### Row type mismatch

Ensure your RETURNING clause matches what you expect. Squirrel generates types based on the SELECT/RETURNING columns.

### DecodeError("Uuid", "String", [...]) on UUID columns

This error means `uuid.from_bit_array()` rejected the binary data. The "String" in the error is misleading — it comes from Erlang's `classify_dynamic/1` which classifies all byte-aligned binaries as "String". The actual data is a 16-byte binary, not a string.

**Common cause:** The UUID has an invalid version nibble. `youid` only recognizes versions 1–5 and 7. Mock/hand-crafted UUIDs like `a0010000-0000-0000-0000-000000000001` have version 0 and will be rejected. Fix by using `uuid_generate_v7()` in SQL or `uuid.v7()` in Gleam for test data.

### UUID decode works in production but fails in tests

Check if test fixtures use hand-crafted UUIDs. The version nibble (first hex digit of the third group: `xxxxxxxx-xxxx-Vxxx`) must be 1–5 or 7. Replace mock UUIDs with `uuid_generate_v7()` calls.

## Critical: Never Modify Generated sql.gleam Files

**The `sql.gleam` files generated by Squirrel should NEVER be manually edited.** Any manual changes will be lost on next `gleam run -m squirrel`.

Workflow: Write SQL → Run Squirrel → Update view layer if needed → Never edit sql.gleam.

## Best Practice: Model Layer Helper

Create a reusable extraction helper:

```gleam
fn extract_first(rows: List(a)) -> Result(a, error.Error) {
  case rows {
    [row] -> Ok(row)
    [] -> Error(error.NotFound("Record not found"))
    _ -> Error(error.InternalServerError("Unexpected result"))
  }
}
```

## SQL Authoring Rules

1. **One query per file** - Squirrel cannot handle multiple queries
2. **Prefix enum values** - Avoid naming conflicts across enums
3. **Use `timestamp` not `timestamptz`** - Squirrel doesn't support timestamptz
4. **Use RETURNING** - Always return data from INSERT/UPDATE
5. **Never edit sql.gleam** - Fix SQL source, re-run Squirrel
6. **No self-aliases** - Never write `column as column`. Use bare column names
7. **No `"column?"` aliases** - Squirrel reads nullability from the schema
8. **No NULLIF** - No sentinel patterns. Pass parameters directly
9. **No `::text` on UUIDs** - Squirrel decodes UUIDs natively
10. **COALESCE only for**: aggregate defaults, partial updates, nullable enum defaults
